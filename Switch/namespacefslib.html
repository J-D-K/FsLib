<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FsLib::Switch: fslib Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FsLib::Switch
   </div>
   <div id="projectbrief">WIP Switch FS function wrapper library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">fslib Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Contains the function for constructing error strings.  
<a href="namespacefslib.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacefslib_1_1dev" id="r_namespacefslib_1_1dev"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib_1_1dev.html">dev</a></td></tr>
<tr class="memdesc:namespacefslib_1_1dev"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the function for overriding fs_dev. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacefslib_1_1device" id="r_namespacefslib_1_1device"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib_1_1device.html">device</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacefslib_1_1error" id="r_namespacefslib_1_1error"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib_1_1error.html">error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfslib_1_1Directory.html">Directory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for opening and reading entries from directories.  <a href="classfslib_1_1Directory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfslib_1_1DirectoryEntry.html">DirectoryEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfslib_1_1File.html">File</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for opening, reading, and writing to files.  <a href="classfslib_1_1File.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfslib_1_1Path.html">Path</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to make working with the Switch's FS and it's odd rules much easier.  <a href="classfslib_1_1Path.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfslib_1_1SaveInfoReader.html">SaveInfoReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around FsSaveDataInfo reader.  <a href="classfslib_1_1SaveInfoReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfslib_1_1Storage.html">Storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading from raw storage volumes.  <a href="classfslib_1_1Storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfslib_1_1Stream.html">Stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class all <a class="el" href="classfslib_1_1File.html" title="Class for opening, reading, and writing to files.">File</a> and storage types are derived from.  <a href="classfslib_1_1Stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1f7a72d57e907058229738df21882943" id="r_a1f7a72d57e907058229738df21882943"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a1f7a72d57e907058229738df21882943">open_bis_filesystem</a> (std::string_view deviceName, FsBisPartitionId partitionID)</td></tr>
<tr class="memdesc:a1f7a72d57e907058229738df21882943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens partition with ID passed.  <br /></td></tr>
<tr class="separator:a1f7a72d57e907058229738df21882943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523f40b7a59df0cdbac347a8ebf3fb97" id="r_a523f40b7a59df0cdbac347a8ebf3fb97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a523f40b7a59df0cdbac347a8ebf3fb97">commit_data_to_file_system</a> (std::string_view deviceName)</td></tr>
<tr class="memdesc:a523f40b7a59df0cdbac347a8ebf3fb97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to commit data to DeviceName.  <br /></td></tr>
<tr class="separator:a523f40b7a59df0cdbac347a8ebf3fb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79e6d3a699ccca8dca4a50918e8a1b1" id="r_ad79e6d3a699ccca8dca4a50918e8a1b1"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#ad79e6d3a699ccca8dca4a50918e8a1b1">get_device_free_space</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;deviceRoot)</td></tr>
<tr class="memdesc:ad79e6d3a699ccca8dca4a50918e8a1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to get the free space available on Device passed.  <br /></td></tr>
<tr class="separator:ad79e6d3a699ccca8dca4a50918e8a1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae58ed84b5006720c5ed90c1192c862" id="r_abae58ed84b5006720c5ed90c1192c862"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#abae58ed84b5006720c5ed90c1192c862">get_device_total_space</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;deviceRoot)</td></tr>
<tr class="memdesc:abae58ed84b5006720c5ed90c1192c862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to get the total space of Device passed.  <br /></td></tr>
<tr class="separator:abae58ed84b5006720c5ed90c1192c862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d775c6c6439301bba609b5bde1106f4" id="r_a0d775c6c6439301bba609b5bde1106f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a0d775c6c6439301bba609b5bde1106f4">create_directory</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;directoryPath)</td></tr>
<tr class="memdesc:a0d775c6c6439301bba609b5bde1106f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to create directory with directoryPath.  <br /></td></tr>
<tr class="separator:a0d775c6c6439301bba609b5bde1106f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409f47782ecd952ee4b816ff71c8a023" id="r_a409f47782ecd952ee4b816ff71c8a023"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a409f47782ecd952ee4b816ff71c8a023">create_directories_recursively</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;directoryPath)</td></tr>
<tr class="memdesc:a409f47782ecd952ee4b816ff71c8a023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to create all directories in path if possible. <a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> does not need a trailing slash.  <br /></td></tr>
<tr class="separator:a409f47782ecd952ee4b816ff71c8a023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fb022244f8cbd5377653e2c710c467" id="r_a93fb022244f8cbd5377653e2c710c467"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a93fb022244f8cbd5377653e2c710c467">delete_directory</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;directoryPath)</td></tr>
<tr class="memdesc:a93fb022244f8cbd5377653e2c710c467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to delete the directory passed.  <br /></td></tr>
<tr class="separator:a93fb022244f8cbd5377653e2c710c467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb974dd082c542e6302e24f546b6c3b" id="r_a4eb974dd082c542e6302e24f546b6c3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a4eb974dd082c542e6302e24f546b6c3b">delete_directory_recursively</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;directoryPath)</td></tr>
<tr class="memdesc:a4eb974dd082c542e6302e24f546b6c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to delete directory path recursively.  <br /></td></tr>
<tr class="separator:a4eb974dd082c542e6302e24f546b6c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ff3331beb49334a4fd8627c4a07854" id="r_a25ff3331beb49334a4fd8627c4a07854"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a25ff3331beb49334a4fd8627c4a07854">directory_exists</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;directoryPath)</td></tr>
<tr class="memdesc:a25ff3331beb49334a4fd8627c4a07854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to open directory for reading to see if it exists. Can also be used to test if something is a directory.  <br /></td></tr>
<tr class="separator:a25ff3331beb49334a4fd8627c4a07854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30275b0b56e87151cd18a8446691b650" id="r_a30275b0b56e87151cd18a8446691b650"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a30275b0b56e87151cd18a8446691b650">rename_directory</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;oldPath, const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;newPath)</td></tr>
<tr class="memdesc:a30275b0b56e87151cd18a8446691b650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to rename OldPath to NewPath.  <br /></td></tr>
<tr class="separator:a30275b0b56e87151cd18a8446691b650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b70c3c34f2a951d23dfbc23349b1bc0" id="r_a6b70c3c34f2a951d23dfbc23349b1bc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a6b70c3c34f2a951d23dfbc23349b1bc0">get_directory_entry_count</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;directoryPath, int64_t &amp;countOut)</td></tr>
<tr class="memdesc:a6b70c3c34f2a951d23dfbc23349b1bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to get a count for the number of entries in a directory.  <br /></td></tr>
<tr class="separator:a6b70c3c34f2a951d23dfbc23349b1bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac6df1e16c03dc798c844195e5c4db6" id="r_acac6df1e16c03dc798c844195e5c4db6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#acac6df1e16c03dc798c844195e5c4db6">create_file</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;filePath, int64_t fileSize=0)</td></tr>
<tr class="memdesc:acac6df1e16c03dc798c844195e5c4db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to create file with FileSize.  <br /></td></tr>
<tr class="separator:acac6df1e16c03dc798c844195e5c4db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97293f7c656df7478dd9263867f62984" id="r_a97293f7c656df7478dd9263867f62984"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a97293f7c656df7478dd9263867f62984">file_exists</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;filePath)</td></tr>
<tr class="memdesc:a97293f7c656df7478dd9263867f62984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if the file exists. Can also be used to check if item is a file.  <br /></td></tr>
<tr class="separator:a97293f7c656df7478dd9263867f62984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b46f45cc4bfd716dbcd300ab1b4a40" id="r_a03b46f45cc4bfd716dbcd300ab1b4a40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a03b46f45cc4bfd716dbcd300ab1b4a40">delete_file</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;filePath)</td></tr>
<tr class="memdesc:a03b46f45cc4bfd716dbcd300ab1b4a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to delete file.  <br /></td></tr>
<tr class="separator:a03b46f45cc4bfd716dbcd300ab1b4a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728356eaa8eb618c1db7dcaa03cbaf44" id="r_a728356eaa8eb618c1db7dcaa03cbaf44"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a728356eaa8eb618c1db7dcaa03cbaf44">get_file_size</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;filePath)</td></tr>
<tr class="memdesc:a728356eaa8eb618c1db7dcaa03cbaf44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to get file's size.  <br /></td></tr>
<tr class="separator:a728356eaa8eb618c1db7dcaa03cbaf44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a4c4a4eabc67c435602c2abafe5227" id="r_ad7a4c4a4eabc67c435602c2abafe5227"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#ad7a4c4a4eabc67c435602c2abafe5227">rename_file</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;oldPath, const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;newPath)</td></tr>
<tr class="memdesc:ad7a4c4a4eabc67c435602c2abafe5227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to rename OldPath to NewPath.  <br /></td></tr>
<tr class="separator:ad7a4c4a4eabc67c435602c2abafe5227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8c82ae39646986fa70d1382c79fd35" id="r_a2d8c82ae39646986fa70d1382c79fd35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a2d8c82ae39646986fa70d1382c79fd35">get_file_timestamp</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;filePath, FsTimeStampRaw &amp;stampOut)</td></tr>
<tr class="memdesc:a2d8c82ae39646986fa70d1382c79fd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to retrieve a timestamp for the path passed.  <br /></td></tr>
<tr class="separator:a2d8c82ae39646986fa70d1382c79fd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fde3f2f9ae9e84f5a50afd3e1403fae" id="r_a5fde3f2f9ae9e84f5a50afd3e1403fae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a5fde3f2f9ae9e84f5a50afd3e1403fae">is_initialized</a> ()</td></tr>
<tr class="memdesc:a5fde3f2f9ae9e84f5a50afd3e1403fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not <a class="el" href="classFsLibCore.html">FsLibCore</a> was initialized successfully.  <br /></td></tr>
<tr class="separator:a5fde3f2f9ae9e84f5a50afd3e1403fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f65efd09a2fffc7c2a5265f7c1267b" id="r_af4f65efd09a2fffc7c2a5265f7c1267b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#af4f65efd09a2fffc7c2a5265f7c1267b">map_file_system</a> (std::string_view deviceName, FsFileSystem &amp;filesystem)</td></tr>
<tr class="memdesc:af4f65efd09a2fffc7c2a5265f7c1267b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps <a class="el" href="classFileSystem.html">FileSystem</a> to DeviceName internally.  <br /></td></tr>
<tr class="separator:af4f65efd09a2fffc7c2a5265f7c1267b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6fa5119343fe790f4f9cc08701c4f9" id="r_a5d6fa5119343fe790f4f9cc08701c4f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a5d6fa5119343fe790f4f9cc08701c4f9">get_file_system_by_device_name</a> (std::string_view deviceName, FsFileSystem **filesystem)</td></tr>
<tr class="memdesc:a5d6fa5119343fe790f4f9cc08701c4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find Device in map.  <br /></td></tr>
<tr class="separator:a5d6fa5119343fe790f4f9cc08701c4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b8123fc0656bd63a84ac7c2e75eb36" id="r_a77b8123fc0656bd63a84ac7c2e75eb36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a77b8123fc0656bd63a84ac7c2e75eb36">close_file_system</a> (std::string_view deviceName)</td></tr>
<tr class="memdesc:a77b8123fc0656bd63a84ac7c2e75eb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes filesystem mapped to DeviceName.  <br /></td></tr>
<tr class="separator:a77b8123fc0656bd63a84ac7c2e75eb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d92ec67e9d3bf27b40d2c0e61a5e56" id="r_a20d92ec67e9d3bf27b40d2c0e61a5e56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfslib_1_1Path.html">fslib::Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a20d92ec67e9d3bf27b40d2c0e61a5e56">operator/</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;pathA, const char *pathB)</td></tr>
<tr class="memdesc:a20d92ec67e9d3bf27b40d2c0e61a5e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two paths. Adds a / if needed.  <br /></td></tr>
<tr class="separator:a20d92ec67e9d3bf27b40d2c0e61a5e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6beed8dc9ca6e409817f95506ab3d829" id="r_a6beed8dc9ca6e409817f95506ab3d829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfslib_1_1Path.html">fslib::Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a6beed8dc9ca6e409817f95506ab3d829">operator/</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;pathA, const std::string &amp;pathB)</td></tr>
<tr class="memdesc:a6beed8dc9ca6e409817f95506ab3d829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two paths. Adds a / if needed.  <br /></td></tr>
<tr class="separator:a6beed8dc9ca6e409817f95506ab3d829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73bb93065b1b7154c98eca66b9603709" id="r_a73bb93065b1b7154c98eca66b9603709"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfslib_1_1Path.html">fslib::Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a73bb93065b1b7154c98eca66b9603709">operator/</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;pathA, std::string_view pathB)</td></tr>
<tr class="memdesc:a73bb93065b1b7154c98eca66b9603709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two paths. Adds a / if needed.  <br /></td></tr>
<tr class="separator:a73bb93065b1b7154c98eca66b9603709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4f9efd14044aedd3fa7390093dea27" id="r_aab4f9efd14044aedd3fa7390093dea27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfslib_1_1Path.html">fslib::Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#aab4f9efd14044aedd3fa7390093dea27">operator/</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;pathA, const std::filesystem::path &amp;pathB)</td></tr>
<tr class="memdesc:aab4f9efd14044aedd3fa7390093dea27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two paths. Adds a / if needed.  <br /></td></tr>
<tr class="separator:aab4f9efd14044aedd3fa7390093dea27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac679ef17f95e4140e933d67329cfc37e" id="r_ac679ef17f95e4140e933d67329cfc37e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfslib_1_1Path.html">fslib::Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#ac679ef17f95e4140e933d67329cfc37e">operator/</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;pathA, const <a class="el" href="classfslib_1_1DirectoryEntry.html">fslib::DirectoryEntry</a> &amp;pathB)</td></tr>
<tr class="memdesc:ac679ef17f95e4140e933d67329cfc37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two paths. Adds a / if needed.  <br /></td></tr>
<tr class="separator:ac679ef17f95e4140e933d67329cfc37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0564ec7127868cf8e87ffc11b6f63509" id="r_a0564ec7127868cf8e87ffc11b6f63509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfslib_1_1Path.html">fslib::Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a0564ec7127868cf8e87ffc11b6f63509">operator+</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;pathA, const char *pathB)</td></tr>
<tr class="memdesc:a0564ec7127868cf8e87ffc11b6f63509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unchecked concatenation operator. Doesn't perform checks or add / if needed.  <br /></td></tr>
<tr class="separator:a0564ec7127868cf8e87ffc11b6f63509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7361c7ea1a3259e7ee19db883ed453" id="r_a0b7361c7ea1a3259e7ee19db883ed453"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfslib_1_1Path.html">fslib::Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a0b7361c7ea1a3259e7ee19db883ed453">operator+</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;pathA, const std::string &amp;pathB)</td></tr>
<tr class="memdesc:a0b7361c7ea1a3259e7ee19db883ed453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unchecked concatenation operator. Doesn't perform checks or add / if needed.  <br /></td></tr>
<tr class="separator:a0b7361c7ea1a3259e7ee19db883ed453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963c66b98041196feab25b641ff4300d" id="r_a963c66b98041196feab25b641ff4300d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfslib_1_1Path.html">fslib::Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a963c66b98041196feab25b641ff4300d">operator+</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;pathA, std::string_view pathB)</td></tr>
<tr class="memdesc:a963c66b98041196feab25b641ff4300d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unchecked concatenation operator. Doesn't perform checks or add / if needed.  <br /></td></tr>
<tr class="separator:a963c66b98041196feab25b641ff4300d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb66a3ce16e1b50fc3b8e35cd99fce3b" id="r_abb66a3ce16e1b50fc3b8e35cd99fce3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfslib_1_1Path.html">fslib::Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#abb66a3ce16e1b50fc3b8e35cd99fce3b">operator+</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;pathA, const std::filesystem::path &amp;pathB)</td></tr>
<tr class="memdesc:abb66a3ce16e1b50fc3b8e35cd99fce3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unchecked concatenation operator. Doesn't perform checks or add / if needed.  <br /></td></tr>
<tr class="separator:abb66a3ce16e1b50fc3b8e35cd99fce3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32365cec99cab42b310d4f1dee66a38" id="r_ae32365cec99cab42b310d4f1dee66a38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfslib_1_1Path.html">fslib::Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#ae32365cec99cab42b310d4f1dee66a38">operator+</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;pathA, const <a class="el" href="classfslib_1_1DirectoryEntry.html">fslib::DirectoryEntry</a> &amp;pathB)</td></tr>
<tr class="memdesc:ae32365cec99cab42b310d4f1dee66a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unchecked concatenation operator. Doesn't perform checks or add / if needed.  <br /></td></tr>
<tr class="separator:ae32365cec99cab42b310d4f1dee66a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225788bf97119104c0d122629528cc19" id="r_a225788bf97119104c0d122629528cc19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a225788bf97119104c0d122629528cc19">operator==</a> (const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;pathA, const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;pathB) noexcept</td></tr>
<tr class="memdesc:a225788bf97119104c0d122629528cc19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator to compared two paths.  <br /></td></tr>
<tr class="separator:a225788bf97119104c0d122629528cc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b13753b08a56a312524f5d7e8b8f4a" id="r_a24b13753b08a56a312524f5d7e8b8f4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a24b13753b08a56a312524f5d7e8b8f4a">open_system_save_file_system</a> (std::string_view deviceName, uint64_t systemSaveID, FsSaveDataSpaceId saveDataSpaceID=FsSaveDataSpaceId_System, FsSaveDataRank saveDataRank=FsSaveDataRank_Primary, AccountUid accountID={0})</td></tr>
<tr class="memdesc:a24b13753b08a56a312524f5d7e8b8f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to open system save data with SystemSaveID and map it to DeviceName.  <br /></td></tr>
<tr class="separator:a24b13753b08a56a312524f5d7e8b8f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af892b19905a6a2dc40b2380053fd74f0" id="r_af892b19905a6a2dc40b2380053fd74f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#af892b19905a6a2dc40b2380053fd74f0">open_account_save_file_system</a> (std::string_view deviceName, uint64_t applicationID, AccountUid userID, FsSaveDataSpaceId saveDataSpaceID=FsSaveDataSpaceId_User, FsSaveDataRank saveDataRank=FsSaveDataRank_Primary)</td></tr>
<tr class="memdesc:af892b19905a6a2dc40b2380053fd74f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to open account save data with ApplicationID and UserID and map it to DeviceName.  <br /></td></tr>
<tr class="separator:af892b19905a6a2dc40b2380053fd74f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86110d24fcf2f21ab4872d9fc9925c3f" id="r_a86110d24fcf2f21ab4872d9fc9925c3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a86110d24fcf2f21ab4872d9fc9925c3f">open_bcat_save_file_system</a> (std::string_view deviceName, uint64_t applicationID)</td></tr>
<tr class="memdesc:a86110d24fcf2f21ab4872d9fc9925c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to open BCAT save data with ApplicationID and map it to DeviceName.  <br /></td></tr>
<tr class="separator:a86110d24fcf2f21ab4872d9fc9925c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4594326e930ff8ce4cce7d77c98ca3c8" id="r_a4594326e930ff8ce4cce7d77c98ca3c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a4594326e930ff8ce4cce7d77c98ca3c8">open_device_save_file_system</a> (std::string_view deviceName, uint64_t applicationID)</td></tr>
<tr class="memdesc:a4594326e930ff8ce4cce7d77c98ca3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to open device save data with ApplicationID and map it to DeviceName.  <br /></td></tr>
<tr class="separator:a4594326e930ff8ce4cce7d77c98ca3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd030c25c114b2cc11d22acc77c55eb" id="r_a8cd030c25c114b2cc11d22acc77c55eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a8cd030c25c114b2cc11d22acc77c55eb">open_temporary_save_file_system</a> (std::string_view deviceName)</td></tr>
<tr class="memdesc:a8cd030c25c114b2cc11d22acc77c55eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to open temporary save data and map it to DeviceName.  <br /></td></tr>
<tr class="separator:a8cd030c25c114b2cc11d22acc77c55eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2ef9b6f24cca8fccdb4923e6efb64e" id="r_aaf2ef9b6f24cca8fccdb4923e6efb64e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#aaf2ef9b6f24cca8fccdb4923e6efb64e">open_cache_save_file_system</a> (std::string_view deviceName, uint64_t applicationID, uint16_t saveDataIndex, FsSaveDataSpaceId saveDataSpaceID=FsSaveDataSpaceId_User, FsSaveDataRank saveDataRank=FsSaveDataRank_Primary)</td></tr>
<tr class="memdesc:aaf2ef9b6f24cca8fccdb4923e6efb64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to open cache save data and map it to DeviceName.  <br /></td></tr>
<tr class="separator:aaf2ef9b6f24cca8fccdb4923e6efb64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf817c762e337bd7275860eeedf82fcc" id="r_abf817c762e337bd7275860eeedf82fcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#abf817c762e337bd7275860eeedf82fcc">open_system_bcat_save_file_system</a> (std::string_view deviceName, uint64_t systemSaveID)</td></tr>
<tr class="memdesc:abf817c762e337bd7275860eeedf82fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to open system BCAT save data and map it to DeviceName.  <br /></td></tr>
<tr class="separator:abf817c762e337bd7275860eeedf82fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec48502058759b681c434711adebc66" id="r_a7ec48502058759b681c434711adebc66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefslib.html#a7ec48502058759b681c434711adebc66">open_save_data_with_save_info</a> (std::string_view deviceName, const FsSaveDataInfo &amp;saveInfo)</td></tr>
<tr class="memdesc:a7ec48502058759b681c434711adebc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to open save data with FsSaveDataInfo passed.  <br /></td></tr>
<tr class="separator:a7ec48502058759b681c434711adebc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains the function for constructing error strings. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a1f7a72d57e907058229738df21882943" name="a1f7a72d57e907058229738df21882943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7a72d57e907058229738df21882943">&#9670;&#160;</a></span>open_bis_filesystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::open_bis_filesystem </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>deviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FsBisPartitionId&#160;</td>
          <td class="paramname"><em>partitionID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens partition with ID passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceName</td><td>Name to map to partition. </td></tr>
    <tr><td class="paramname">partitionID</td><td>ID of BIS partition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>

</div>
</div>
<a id="a523f40b7a59df0cdbac347a8ebf3fb97" name="a523f40b7a59df0cdbac347a8ebf3fb97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523f40b7a59df0cdbac347a8ebf3fb97">&#9670;&#160;</a></span>commit_data_to_file_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::commit_data_to_file_system </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>deviceName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to commit data to DeviceName. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceName</td><td>Name of device to commit data to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>

</div>
</div>
<a id="ad79e6d3a699ccca8dca4a50918e8a1b1" name="ad79e6d3a699ccca8dca4a50918e8a1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79e6d3a699ccca8dca4a50918e8a1b1">&#9670;&#160;</a></span>get_device_free_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t fslib::get_device_free_space </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceRoot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to get the free space available on Device passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceRoot</td><td>Root of device. </td></tr>
    <tr><td class="paramname">sizeOut</td><td>The size retrieved if successful. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size on success. -1 on failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function requires a path to work. DeviceRoot should be <code>sdmc:/</code> instead of <code>sdmc</code>, for example. </dd></dl>

</div>
</div>
<a id="abae58ed84b5006720c5ed90c1192c862" name="abae58ed84b5006720c5ed90c1192c862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae58ed84b5006720c5ed90c1192c862">&#9670;&#160;</a></span>get_device_total_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t fslib::get_device_total_space </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceRoot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to get the total space of Device passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceRoot</td><td>Root of device. </td></tr>
    <tr><td class="paramname">sizeOut</td><td>The size retrieved if successful. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size on success. -1 on failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function requires a path to work. DeviceRoot should be <code>sdmc:/</code> instead of <code>sdmc</code>, for example. </dd></dl>

</div>
</div>
<a id="a0d775c6c6439301bba609b5bde1106f4" name="a0d775c6c6439301bba609b5bde1106f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d775c6c6439301bba609b5bde1106f4">&#9670;&#160;</a></span>create_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::create_directory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>directoryPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to create directory with directoryPath. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directoryPath</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> to new directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>

</div>
</div>
<a id="a409f47782ecd952ee4b816ff71c8a023" name="a409f47782ecd952ee4b816ff71c8a023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409f47782ecd952ee4b816ff71c8a023">&#9670;&#160;</a></span>create_directories_recursively()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::create_directories_recursively </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>directoryPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to create all directories in path if possible. <a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> does not need a trailing slash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directoryPath</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> of directories. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This can be kind of slow. At the moment, I'm not sure if there's a bug or Switch has some kind of limit on folder depth, but after a certain point this will fail. Use only where <b>absolutely needed</b>. </dd></dl>

</div>
</div>
<a id="a93fb022244f8cbd5377653e2c710c467" name="a93fb022244f8cbd5377653e2c710c467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93fb022244f8cbd5377653e2c710c467">&#9670;&#160;</a></span>delete_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::delete_directory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>directoryPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to delete the directory passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directoryPath</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> to the target directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>

</div>
</div>
<a id="a4eb974dd082c542e6302e24f546b6c3b" name="a4eb974dd082c542e6302e24f546b6c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb974dd082c542e6302e24f546b6c3b">&#9670;&#160;</a></span>delete_directory_recursively()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::delete_directory_recursively </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>directoryPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to delete directory path recursively. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directoryPath</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> to target directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>

</div>
</div>
<a id="a25ff3331beb49334a4fd8627c4a07854" name="a25ff3331beb49334a4fd8627c4a07854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ff3331beb49334a4fd8627c4a07854">&#9670;&#160;</a></span>directory_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::directory_exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>directoryPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to open directory for reading to see if it exists. Can also be used to test if something is a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directoryPath</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> to the target directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>

</div>
</div>
<a id="a30275b0b56e87151cd18a8446691b650" name="a30275b0b56e87151cd18a8446691b650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30275b0b56e87151cd18a8446691b650">&#9670;&#160;</a></span>rename_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::rename_directory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>oldPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>newPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to rename OldPath to NewPath. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldPath</td><td>Original path to target directory. </td></tr>
    <tr><td class="paramname">newPath</td><td>New path to target directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>

</div>
</div>
<a id="a6b70c3c34f2a951d23dfbc23349b1bc0" name="a6b70c3c34f2a951d23dfbc23349b1bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b70c3c34f2a951d23dfbc23349b1bc0">&#9670;&#160;</a></span>get_directory_entry_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::get_directory_entry_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>directoryPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>countOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to get a count for the number of entries in a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directoryPath</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> of the directory to get the entry count for. </td></tr>
    <tr><td class="paramname">countOut</td><td>Int64_t to write the count to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>

</div>
</div>
<a id="acac6df1e16c03dc798c844195e5c4db6" name="acac6df1e16c03dc798c844195e5c4db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac6df1e16c03dc798c844195e5c4db6">&#9670;&#160;</a></span>create_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::create_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>fileSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to create file with FileSize. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> to file to create. </td></tr>
    <tr><td class="paramname">fileSize</td><td>Optional. The size to use when creating the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>

</div>
</div>
<a id="a97293f7c656df7478dd9263867f62984" name="a97293f7c656df7478dd9263867f62984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97293f7c656df7478dd9263867f62984">&#9670;&#160;</a></span>file_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::file_exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if the file exists. Can also be used to check if item is a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> of target file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it exists. False if it doesn't. </dd></dl>

</div>
</div>
<a id="a03b46f45cc4bfd716dbcd300ab1b4a40" name="a03b46f45cc4bfd716dbcd300ab1b4a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b46f45cc4bfd716dbcd300ab1b4a40">&#9670;&#160;</a></span>delete_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::delete_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to delete file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> of target file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>

</div>
</div>
<a id="a728356eaa8eb618c1db7dcaa03cbaf44" name="a728356eaa8eb618c1db7dcaa03cbaf44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728356eaa8eb618c1db7dcaa03cbaf44">&#9670;&#160;</a></span>get_file_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t fslib::get_file_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to get file's size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> of target file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classfslib_1_1File.html" title="Class for opening, reading, and writing to files.">File</a>'s size on success. -1 on error. </dd></dl>

</div>
</div>
<a id="ad7a4c4a4eabc67c435602c2abafe5227" name="ad7a4c4a4eabc67c435602c2abafe5227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a4c4a4eabc67c435602c2abafe5227">&#9670;&#160;</a></span>rename_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::rename_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>oldPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>newPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to rename OldPath to NewPath. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldPath</td><td>Original path of target file. </td></tr>
    <tr><td class="paramname">newPath</td><td>New path of target file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>

</div>
</div>
<a id="a2d8c82ae39646986fa70d1382c79fd35" name="a2d8c82ae39646986fa70d1382c79fd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8c82ae39646986fa70d1382c79fd35">&#9670;&#160;</a></span>get_file_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::get_file_timestamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FsTimeStampRaw &amp;&#160;</td>
          <td class="paramname"><em>stampOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to retrieve a timestamp for the path passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> of the file to get the timestamp for. </td></tr>
    <tr><td class="paramname">stampOut</td><td>FsTimeStampRaw to write the POSIX timestamp to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>

</div>
</div>
<a id="a5fde3f2f9ae9e84f5a50afd3e1403fae" name="a5fde3f2f9ae9e84f5a50afd3e1403fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fde3f2f9ae9e84f5a50afd3e1403fae">&#9670;&#160;</a></span>is_initialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::is_initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether or not <a class="el" href="classFsLibCore.html">FsLibCore</a> was initialized successfully. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="af4f65efd09a2fffc7c2a5265f7c1267b" name="af4f65efd09a2fffc7c2a5265f7c1267b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f65efd09a2fffc7c2a5265f7c1267b">&#9670;&#160;</a></span>map_file_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::map_file_system </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>deviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FsFileSystem &amp;&#160;</td>
          <td class="paramname"><em>filesystem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps <a class="el" href="classFileSystem.html">FileSystem</a> to DeviceName internally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceName</td><td>Name to use for Device. </td></tr>
    <tr><td class="paramname">filesystem</td><td><a class="el" href="classFileSystem.html">FileSystem</a> to map to DeviceName. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If a <a class="el" href="classFileSystem.html">FileSystem</a> is already mapped to DeviceName, it <b>will</b> be unmounted and replaced with <a class="el" href="classFileSystem.html">FileSystem</a> instead of just returning NULL like fs_dev. There is also <b>no</b> real limit to how many devices you can have open besides the Switch handle limit. fs_dev only allows 32 at a time. </dd></dl>

</div>
</div>
<a id="a5d6fa5119343fe790f4f9cc08701c4f9" name="a5d6fa5119343fe790f4f9cc08701c4f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6fa5119343fe790f4f9cc08701c4f9">&#9670;&#160;</a></span>get_file_system_by_device_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::get_file_system_by_device_name </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>deviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FsFileSystem **&#160;</td>
          <td class="paramname"><em>filesystem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to find Device in map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceName</td><td>Name of the Device to locate. </td></tr>
    <tr><td class="paramname">filesystemOut</td><td>Set to pointer to <a class="el" href="classFileSystem.html">FileSystem</a> handle mapped to DeviceName. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if DeviceName is found, false if it isn't. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This isn't really useful outside of internal FsLib functions, but I don't want to hide it like archive_dev does in ctrulib. </dd></dl>

</div>
</div>
<a id="a77b8123fc0656bd63a84ac7c2e75eb36" name="a77b8123fc0656bd63a84ac7c2e75eb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b8123fc0656bd63a84ac7c2e75eb36">&#9670;&#160;</a></span>close_file_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::close_file_system </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>deviceName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes filesystem mapped to DeviceName. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceName</td><td>Name of device to close. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on Failure or device not found. </dd></dl>

</div>
</div>
<a id="a20d92ec67e9d3bf27b40d2c0e61a5e56" name="a20d92ec67e9d3bf27b40d2c0e61a5e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d92ec67e9d3bf27b40d2c0e61a5e56">&#9670;&#160;</a></span>operator/() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfslib_1_1Path.html">fslib::Path</a> fslib::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>pathA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates two paths. Adds a / if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathA</td><td>Base path. </td></tr>
    <tr><td class="paramname">pathB</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> to concatenate to Path1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6beed8dc9ca6e409817f95506ab3d829" name="a6beed8dc9ca6e409817f95506ab3d829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6beed8dc9ca6e409817f95506ab3d829">&#9670;&#160;</a></span>operator/() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfslib_1_1Path.html">fslib::Path</a> fslib::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>pathA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pathB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates two paths. Adds a / if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathA</td><td>Base path. </td></tr>
    <tr><td class="paramname">pathB</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> to concatenate to Path1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73bb93065b1b7154c98eca66b9603709" name="a73bb93065b1b7154c98eca66b9603709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73bb93065b1b7154c98eca66b9603709">&#9670;&#160;</a></span>operator/() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfslib_1_1Path.html">fslib::Path</a> fslib::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>pathA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>pathB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates two paths. Adds a / if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathA</td><td>Base path. </td></tr>
    <tr><td class="paramname">pathB</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> to concatenate to Path1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab4f9efd14044aedd3fa7390093dea27" name="aab4f9efd14044aedd3fa7390093dea27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab4f9efd14044aedd3fa7390093dea27">&#9670;&#160;</a></span>operator/() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfslib_1_1Path.html">fslib::Path</a> fslib::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>pathA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>pathB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates two paths. Adds a / if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathA</td><td>Base path. </td></tr>
    <tr><td class="paramname">pathB</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> to concatenate to Path1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac679ef17f95e4140e933d67329cfc37e" name="ac679ef17f95e4140e933d67329cfc37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac679ef17f95e4140e933d67329cfc37e">&#9670;&#160;</a></span>operator/() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfslib_1_1Path.html">fslib::Path</a> fslib::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>pathA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1DirectoryEntry.html">fslib::DirectoryEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>pathB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates two paths. Adds a / if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathA</td><td>Base path. </td></tr>
    <tr><td class="paramname">pathB</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> to concatenate to Path1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0564ec7127868cf8e87ffc11b6f63509" name="a0564ec7127868cf8e87ffc11b6f63509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0564ec7127868cf8e87ffc11b6f63509">&#9670;&#160;</a></span>operator+() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfslib_1_1Path.html">fslib::Path</a> fslib::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>pathA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unchecked concatenation operator. Doesn't perform checks or add / if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathA</td><td>Base path. </td></tr>
    <tr><td class="paramname">pathB</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> to concatenate to Path1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b7361c7ea1a3259e7ee19db883ed453" name="a0b7361c7ea1a3259e7ee19db883ed453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7361c7ea1a3259e7ee19db883ed453">&#9670;&#160;</a></span>operator+() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfslib_1_1Path.html">fslib::Path</a> fslib::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>pathA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pathB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unchecked concatenation operator. Doesn't perform checks or add / if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathA</td><td>Base path. </td></tr>
    <tr><td class="paramname">pathB</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> to concatenate to Path1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a963c66b98041196feab25b641ff4300d" name="a963c66b98041196feab25b641ff4300d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963c66b98041196feab25b641ff4300d">&#9670;&#160;</a></span>operator+() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfslib_1_1Path.html">fslib::Path</a> fslib::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>pathA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>pathB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unchecked concatenation operator. Doesn't perform checks or add / if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathA</td><td>Base path. </td></tr>
    <tr><td class="paramname">pathB</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> to concatenate to Path1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb66a3ce16e1b50fc3b8e35cd99fce3b" name="abb66a3ce16e1b50fc3b8e35cd99fce3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb66a3ce16e1b50fc3b8e35cd99fce3b">&#9670;&#160;</a></span>operator+() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfslib_1_1Path.html">fslib::Path</a> fslib::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>pathA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>pathB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unchecked concatenation operator. Doesn't perform checks or add / if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathA</td><td>Base path. </td></tr>
    <tr><td class="paramname">pathB</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> to concatenate to Path1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae32365cec99cab42b310d4f1dee66a38" name="ae32365cec99cab42b310d4f1dee66a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32365cec99cab42b310d4f1dee66a38">&#9670;&#160;</a></span>operator+() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfslib_1_1Path.html">fslib::Path</a> fslib::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>pathA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1DirectoryEntry.html">fslib::DirectoryEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>pathB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unchecked concatenation operator. Doesn't perform checks or add / if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathA</td><td>Base path. </td></tr>
    <tr><td class="paramname">pathB</td><td><a class="el" href="classfslib_1_1Path.html" title="Class to make working with the Switch&#39;s FS and it&#39;s odd rules much easier.">Path</a> to concatenate to Path1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a225788bf97119104c0d122629528cc19" name="a225788bf97119104c0d122629528cc19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225788bf97119104c0d122629528cc19">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>pathA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfslib_1_1Path.html">fslib::Path</a> &amp;&#160;</td>
          <td class="paramname"><em>pathB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator to compared two paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathA</td><td>First path to compare. </td></tr>
    <tr><td class="paramname">pathB</td><td>Second path to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the paths match. False if they don't. </dd></dl>

</div>
</div>
<a id="a24b13753b08a56a312524f5d7e8b8f4a" name="a24b13753b08a56a312524f5d7e8b8f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b13753b08a56a312524f5d7e8b8f4a">&#9670;&#160;</a></span>open_system_save_file_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::open_system_save_file_system </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>deviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>systemSaveID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FsSaveDataSpaceId&#160;</td>
          <td class="paramname"><em>saveDataSpaceID</em> = <code>FsSaveDataSpaceId_System</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FsSaveDataRank&#160;</td>
          <td class="paramname"><em>saveDataRank</em> = <code>FsSaveDataRank_Primary</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccountUid&#160;</td>
          <td class="paramname"><em>accountID</em> = <code>{0}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to open system save data with SystemSaveID and map it to DeviceName. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceName</td><td>Name of device to map to. </td></tr>
    <tr><td class="paramname">systemSaveID</td><td>ID of system save. </td></tr>
    <tr><td class="paramname">saveDataSpaceID</td><td>(Optional) FsSaveDataSpaceID. </td></tr>
    <tr><td class="paramname">saveDataRank</td><td>(Optional) Rank of save data. </td></tr>
    <tr><td class="paramname">accountID</td><td>(Optional) AccountID to use to open system save. This is usually 0, but can be tied to accounts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>

</div>
</div>
<a id="af892b19905a6a2dc40b2380053fd74f0" name="af892b19905a6a2dc40b2380053fd74f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af892b19905a6a2dc40b2380053fd74f0">&#9670;&#160;</a></span>open_account_save_file_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::open_account_save_file_system </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>deviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>applicationID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccountUid&#160;</td>
          <td class="paramname"><em>userID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FsSaveDataSpaceId&#160;</td>
          <td class="paramname"><em>saveDataSpaceID</em> = <code>FsSaveDataSpaceId_User</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FsSaveDataRank&#160;</td>
          <td class="paramname"><em>saveDataRank</em> = <code>FsSaveDataRank_Primary</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to open account save data with ApplicationID and UserID and map it to DeviceName. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceName</td><td>Name of device to map to. </td></tr>
    <tr><td class="paramname">applicationID</td><td>Title ID of game or title. </td></tr>
    <tr><td class="paramname">userID</td><td>Account ID of user that "owns" the filesystem. </td></tr>
    <tr><td class="paramname">saveDataSpaceID</td><td>(Optional) Save data space ID. </td></tr>
    <tr><td class="paramname">saveDataRank</td><td>(Optional) SaveDataRank. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>

</div>
</div>
<a id="a86110d24fcf2f21ab4872d9fc9925c3f" name="a86110d24fcf2f21ab4872d9fc9925c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86110d24fcf2f21ab4872d9fc9925c3f">&#9670;&#160;</a></span>open_bcat_save_file_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::open_bcat_save_file_system </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>deviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>applicationID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to open BCAT save data with ApplicationID and map it to DeviceName. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceName</td><td>Name of device to map to. </td></tr>
    <tr><td class="paramname">applicationID</td><td>Title ID of game or title. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>

</div>
</div>
<a id="a4594326e930ff8ce4cce7d77c98ca3c8" name="a4594326e930ff8ce4cce7d77c98ca3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4594326e930ff8ce4cce7d77c98ca3c8">&#9670;&#160;</a></span>open_device_save_file_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::open_device_save_file_system </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>deviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>applicationID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to open device save data with ApplicationID and map it to DeviceName. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceName</td><td>Name of device to map to. </td></tr>
    <tr><td class="paramname">applicationID</td><td>Title ID of game or title. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>

</div>
</div>
<a id="a8cd030c25c114b2cc11d22acc77c55eb" name="a8cd030c25c114b2cc11d22acc77c55eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd030c25c114b2cc11d22acc77c55eb">&#9670;&#160;</a></span>open_temporary_save_file_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::open_temporary_save_file_system </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>deviceName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to open temporary save data and map it to DeviceName. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceName</td><td>Name of device to map to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>I've only ever seen this used once before... </dd></dl>

</div>
</div>
<a id="aaf2ef9b6f24cca8fccdb4923e6efb64e" name="aaf2ef9b6f24cca8fccdb4923e6efb64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2ef9b6f24cca8fccdb4923e6efb64e">&#9670;&#160;</a></span>open_cache_save_file_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::open_cache_save_file_system </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>deviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>applicationID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>saveDataIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FsSaveDataSpaceId&#160;</td>
          <td class="paramname"><em>saveDataSpaceID</em> = <code>FsSaveDataSpaceId_User</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FsSaveDataRank&#160;</td>
          <td class="paramname"><em>saveDataRank</em> = <code>FsSaveDataRank_Primary</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to open cache save data and map it to DeviceName. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceName</td><td>Name of device to map to. </td></tr>
    <tr><td class="paramname">applicationID</td><td>Title ID of game or title. </td></tr>
    <tr><td class="paramname">saveDataIndex</td><td>Index of the cache save. </td></tr>
    <tr><td class="paramname">saveDataSpaceID</td><td>(Optional) Save data space ID. </td></tr>
    <tr><td class="paramname">saveDataRank</td><td>(Optional) Save data rank. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>

</div>
</div>
<a id="abf817c762e337bd7275860eeedf82fcc" name="abf817c762e337bd7275860eeedf82fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf817c762e337bd7275860eeedf82fcc">&#9670;&#160;</a></span>open_system_bcat_save_file_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::open_system_bcat_save_file_system </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>deviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>systemSaveID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to open system BCAT save data and map it to DeviceName. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceName</td><td>Name of device to map to. </td></tr>
    <tr><td class="paramname">systemSaveID</td><td>ID of system save. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>I've never seen this used before. Literally <b>ever</b>. </dd></dl>

</div>
</div>
<a id="a7ec48502058759b681c434711adebc66" name="a7ec48502058759b681c434711adebc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec48502058759b681c434711adebc66">&#9670;&#160;</a></span>open_save_data_with_save_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fslib::open_save_data_with_save_info </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>deviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FsSaveDataInfo &amp;&#160;</td>
          <td class="paramname"><em>saveInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to open save data with FsSaveDataInfo passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceName</td><td>Name of device to map to. </td></tr>
    <tr><td class="paramname">saveInfo</td><td>FsSaveDataInfo to mount from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. False on failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
